### 为什么使用Spring ?
- 方便解耦，简化开发  
&nbsp;&nbsp;&nbsp;&nbsp;通过Spring提供的IoC容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。  
- AOP编程的支持  
&nbsp;&nbsp;&nbsp;&nbsp;通过Spring提供的AOP功能，方便进行面向切面的编程，如性能监测、事务管理、日志记录等。  
- 声明式事务的支持  
- 方便集成各种优秀框架  
- 降低Java EE API的使用难度  
&nbsp;&nbsp;&nbsp;&nbsp;如对JDBC，JavaMail，远程调用等提供了简便封装
### 缓存雪崩和缓存穿透问题
#### 缓存穿透  
&nbsp;&nbsp;&nbsp;&nbsp;缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
##### 解决方案
- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
- 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。
#### 缓存雪崩  
&nbsp;&nbsp;&nbsp;&nbsp;缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
##### 解决方案
- 给缓存的失效时间，加上一个随机值，避免集体失效。
- 使用互斥锁，但是该方案吞吐量明显下降了。
- 双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点  
&nbsp;&nbsp;&nbsp;&nbsp;a. 从缓存A读数据库，有则直接返回  
&nbsp;&nbsp;&nbsp;&nbsp;b. A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。  
&nbsp;&nbsp;&nbsp;&nbsp;c. 更新线程同时更新缓存A和缓存B。  
### cookie和session区别

-   cookie以文本格式存储在浏览器上，存储量有限；而会话存储在服务端，可以无限量存储多个变量并且比cookie更安全
-   cookie存储的是用户信息，不安全，容易造成隐私泄露，而session存储的是会话值，在服务器端不容易获取，相对安全。
-   cookie的存储限制了数据量，只允许4KB，而session是无限量的
-   设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话
### Ajax的工作原理和优缺点
#### 工作原理
- 相当于在客户端与服务端之间加了一个抽象层(Ajax引擎)，使用户请求和服务器响应异步化，并不是所有的请求都提交给服务器，像一些数据验证和数据处理都交给Ajax引擎来完成，只有确认需要向服务器读取新数据时才右Ajax引擎向服务器提交请求。
#### 优缺点
##### 优点  
- 无刷新更新数据  
&nbsp;&nbsp;&nbsp;&nbsp;Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信  
- 异步与服务器通信  
使用异步的方式与服务器通信，不打断用户的操作  
- 前端与后端负载均衡  
&nbsp;&nbsp;&nbsp;&nbsp;将一些后端的工作移到前端，减少服务器与带宽的负担  
- 基于规范被广泛支持  
&nbsp;&nbsp;&nbsp;&nbsp;不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。  
- 界面与应用分离  
&nbsp;&nbsp;&nbsp;&nbsp;Ajax使得界面与应用分离，也就是数据与呈现分离  
##### 缺点
- Ajax干掉了Back与History功能，即对浏览器机制的破坏  
&nbsp;&nbsp;&nbsp;&nbsp;在动态更新页面的情况下，用户无法回到前一页的页面状态，因为浏览器仅能记忆历史纪录中的静态页面
- 安全问题  
&nbsp;&nbsp;&nbsp;&nbsp;AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。
- 对搜索引擎支持较弱
- 破坏程序的异常处理机制
- 违背URL与资源定位的初衷
- 不能很好地支持移动设备
- 客户端肥大，太多客户段代码造成开发上的成本
### 什么是缓存？你用过那些缓存？
#### 什么是缓存
- 所谓的缓存，就是将程序或系统经常要调用的对象存在内存中，以便其使用时可以快速调用，不必再去创建新的重复的实例。
- 缓存是计算机上的原始数据的复制集，因此对于缓存的使用与应用场景密切相关，在不同的场景上会有不同的意义。
#### 为什么要使用缓存
- 首先对于互联网应用来说，用户体验是非常重要的，而使用缓存的目的是想通过提高服务的性能从而提高应用的用户体验。
- 而系统性能的指标一般包括：响应时间、延迟时间、吞吐量、并发用户数量和资源利用率等几个方面。  
&nbsp;&nbsp;&nbsp;&nbsp;吞吐量：系统在单位时间内处理的请求的数量
#### 缓存的分类（你用过哪些缓存）
对于java程序开发者来说，根据缓存在软件系统中所处的位置的不同，缓存大体可以分为三类：
- 客户端缓存
&nbsp;&nbsp;&nbsp;&nbsp;对于BS架构的互联网应用来说客户端缓存主要分为页面缓存和浏览器缓存两种，对于APP而言主要是自身所使用的缓存。  
- 服务端缓存
&nbsp;&nbsp;&nbsp;&nbsp;网络中的缓存主要是指代理服务器对客户端请求数据的缓存，主要分为WEB代理缓存和边缘缓存(CDN边缘缓存)  
- 网络中缓存
&nbsp;&nbsp;&nbsp;&nbsp;对于服务端缓存而言，从系统的架构上面区分可以将缓存分为  
&nbsp;&nbsp;&nbsp;&nbsp;服务器本读缓存(localCache)  
&nbsp;&nbsp;&nbsp;&nbsp;分布式缓存(Redis、Memcached等nosql)  
&nbsp;&nbsp;&nbsp;&nbsp;数据库缓存  
原文链接:https://www.jianshu.com/p/2c5b1e7d0aaf
###  什么是IOC,为什么使用IOC？
- IOC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。
- 它能指导我们如何设计出松耦合、更优良的程序。
### AOP
#### AOP是什么？
- 面向切面编程，相比较oop 面向对象编程来说，Aop 关注的不再是程序代码中某个类，某些方法，而aop 考虑的更多的是一种面到面
的切入即层与层之间的一种切入，所以称之为切面。
#### AOP用途
- AOP 主要应用于日志记录，性能统计，安全控制,事务处理等方面，实现公共功能性的重复使用。
#### AOP带来的好处
- 降低模块与模块之间的耦合度，提高业务代码的聚合度。（高内聚低耦合）
- 提高了代码的复用性。
- 提高系统的扩展性。
#### Aop关键词
- 连接点:每一个方法
- 切入点:匹配的方法集合
- 切面：连接点与切入点的集合决定了切面，横切关注点的抽象
- 通知:几种通知
- 目标对象:被代理对象
- 织入：程序运行期将切面应用到目标对象并生成代理对象的过程
- 引入:在不修改原始代码情况下，在程序运行期为程序动态引入方法或字段的过程
### 代理模式实现分类以及对应区别
#### 静态代理
- 手动为目标对象制作代理对象，即在程序编译阶段完成代理对象的创建
#### 动态代理
- 在程序运行期动态创建目标对象对应代理对象。  
&nbsp;&nbsp;&nbsp;&nbsp;jdk 动态代理：被代理目标对象必须实现某一或某一组接口实现方式通过回调创建代理对象。  
&nbsp;&nbsp;&nbsp;&nbsp;cglib 动态代理：被代理目标对象可以不必实现接口，继承的方式实现。  
&nbsp;&nbsp;&nbsp;&nbsp;动态代理相比较静态代理，提高开发效率，可以批量化创建代理，提高代码复用率。
### GET和POST区别(以下回答很笼统)
- GET把参数包含在URL中，POST通过request body传递参数。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET产生的URL地址可以被Bookmark，而POST不可以。
原文链接:https://www.cnblogs.com/logsharing/p/8448446.html
### Redis
#### 什么是Redis
- Redis 是一个开源软件拥有（Berkly Software Distribution 许可），它是一个内存数据结构存贮，通常被用于数据库，缓存，消息代理。它支持：字符串，哈希，列表，集合，数组集合，位图，高压缩算法以及地图索引等数据结构。Redis 支持集群，lua 脚本，以及LRU（近期最少使用Least Recently Used）淘汰算法，事物以及不同级别的磁盘持久化，能够提供一个高可用的Redis Sentinel 的集群方案。
#### Redis作用
- Redis 是把数据存放在内存当中，所以它的运行速度会非常快
- Redis 具有多种数据存储结构
- Redis 具有持久化的功能
- Redis 上的数据可以设置过期
- Redis 支持集群，而且可以自动切换
- 跨平台支持多种语言客户端
#### Redis用途
- 缓存（StackOverFlow），数据库(微博)，消息中间件（队列，微博）
### 什么是包装类？你为什么要使用包装类？
- Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。
- Java中许多存储和管理对象集合的有用的类（列表、树、数组等）不能在这些基本类型上进行操作，因为从技术上讲这些基本类型不是从Java对象类派生出来的。
原文链接:https://www.jianshu.com/p/008be5666333
### RPC是什么？RPC和Dubble之间的关系是什么？
#### 什么是RPC协议
原文链接:https://www.jianshu.com/p/8ba4b7b834aa
- 远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
### Dubble有哪些节点
- Provider: 暴露服务的服务提供方。
- Consumer: 调用远程服务的服务消费方。
- Registry: 服务注册与发现的注册中心。
- Monitor: 统计服务的调用次调和调用时间的监控中心。
- Container: 服务运行容器。
### Dubble的调用关系
调用关系说明：
- 0. 服务容器负责启动，加载，运行服务提供者。
- 1. 服务提供者在启动时，向注册中心注册自己提供的服务。
- 2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
- 3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
- 4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
- 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
### 什么是Spring事务？
#### 含义
- 事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。
- 事务由单独单元的一个或者多个sql语句组成，在这个单元中，每个mysql语句时相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或者产生错误，整个单元将会回滚，所有受到影响的数据将会返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务被顺利执行。
#### 事务的属性
- 原子性：一个事务不可在分割，要么都执行要么都不执行。
- 一致性：一个事务的执行会使数据从一个一致状态切换到另一个一致的状态。
- 隔离性：一个事务的执行不受其他事物的干扰
- 持久性： 一个事务一旦提交，则会永久的改变数据库的数据
#### 事务的创建
- 隐式事务：事务没有明显的开启和结束的标记
- 显式事务：事务具有明显的开启和结束的标记 前提：必须先设置自动提交功能为禁用
#### 数据库的隔离级别
- 对于同时运行的多个事务，当这些事务访问数据库中的相同的数据时，如果没有采取必要的隔离机制就会产生并发问题： 脏读，不可重复读，幻读。
- 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响避免并发问题。
- 一个事物与其他事务隔离的程度称为隔离级别。隔离级别越高，，数据一致性就越好，但并发性就越弱。
原文链接:https://blog.csdn.net/hj1997a/article/details/82789240
### tomcat
- Tomcat是一种类似于IIS、Apache的Web服务端程序，也就是Web容器。
### CRM权限模块是怎么实现控制的（流程）？
- 通过权限码
### Spring MVC的请求流程：

1. 发起请求到前端控制器(DispatcherServlet)

2. 第二步：前端控制器请求HandlerMapping查找Handler可以根据xml配置、注解进行查找

3. 第三步：处理器映射器HandlerMapping向前端控制器返回Handler

4. 第四步：前端控制器调用处理器适配器去执行Handler

5. 第五步：处理器适配器去执行Handler

6. 第六步：Handler执行完成给适配器返回ModelAndView

7. 第七步：处理器适配器向前端控制器返回ModelAndView。ModelAndView是springmvc框架的一个底层对象，包括 Model和view

8. 第八步：前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)

9. 第九步：视图解析器向前端控制器返回View

10. 第十步：前端控制器进行视图渲染。视图渲染将模型数据(在ModelAndView对象中)填充到request域

11. 第十一步：前端控制器向用户响应结果
### @RequestMapping的作用
- url映射
- 窄化请求映射
- 限制http请求方法
### Controller方法的返回值
#### 返回ModelAndView 
&nbsp;&nbsp;&nbsp;&nbsp;需要方法结束时，定义ModelAndView，将model和view分别进行设置。 
#### 返回string
- 如果controller方法返回string，  
&nbsp;&nbsp;&nbsp;&nbsp;表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀  
&nbsp;&nbsp;&nbsp;&nbsp;redirect重定向：返回字符串格式为："redirect:queryItem.action"  
&nbsp;&nbsp;&nbsp;&nbsp;forward页面转发：返回字符串格式为：“forward:queryItem.action”  
#### 返回void
- 在controller方法形参上可以定义request和response，使用request或response指定响应结果：
&nbsp;&nbsp;&nbsp;&nbsp;使用request转向页面，如下：request.getRequestDispatcher("页面路径").forward(request,response);  
&nbsp;&nbsp;&nbsp;&nbsp;也可以通过response页面重定向：response.sendRedirect("url")  
&nbsp;&nbsp;&nbsp;&nbsp;也可以通过response指定响应结果.  
